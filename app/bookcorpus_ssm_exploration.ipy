"""Visualisation scrips for the resulting pairwise abstraction matrix.
"""

# %%
from __future__ import annotations

import matplotlib.pyplot as plt
import numpy as np
from matplotlib.gridspec import GridSpec

with open("../data/bookcorpus/ssm_labels.txt", "r") as file:
    labels = [ln.strip() for ln in file.readlines()]


def format_label(label):
    parts = label.strip().split(".")
    return f"{parts[0]}.{int(parts[2])}"


ssm = np.load("../data/bookcorpus/ssm_new_ap0.58.npy")
with open("../data/bookcorpus/plots/all.csv", "r") as file:
    count_dict = {
        format_label(x[0]): int(x[1].strip())
        for x in [line.split(",") for line in file.readlines()]
    }


def label_subset(labels, indices=None):
    return [labels[i] for i in indices] if indices else labels


def count_subset(counts, indices=None):
    return [counts[idx] for idx in indices] if indices else counts.values()


def ssm_subset(matrix, indices=None):
    return (
        np.take(np.take(matrix, indices, axis=0), indices, axis=1)
        if indices
        else matrix
    )


def delete_half(matrix):
    ret = matrix.copy()
    for i, row in enumerate(ret):
        row[range(i, len(row))] = 0
    return ret


mean_abstraction = ssm.mean(axis=1)


def means(l):
    if isinstance(l, int):
        return mean_abstraction[l]
    elif isinstance(l, str):
        index = labels.index(l)
        return mean_abstraction[index]
    raise KeyError(l)


def plot_ssm(indices, cmap="BrBG"):
    matrix_subset = ssm_subset(ssm, indices) if indices else ssm
    labels_subset = label_subset(labels, indices) if indices else labels
    amount = len(labels_subset)
    figsize = max(1, amount // 3.8)

    plt.figure(figsize=(figsize, figsize), dpi=80)
    plt.gca().matshow(matrix_subset.T, cmap=cmap)
    plt.yticks(range(amount), labels_subset)
    plt.xticks(range(amount), labels_subset, rotation=-90)
    plt.show()


def ssmv(fst, snd):
    fsti = fst if isinstance(fst, int) else labels.index(fst)
    sndi = snd if isinstance(snd, int) else labels.index(snd)
    return ssm[fsti, sndi]


def maximal_antichains(G, topo_order=None):
    antichains = map(set, nx.antichains(G, topo_order))
    candidates = []
    for antichain in antichains:
        print(f"Antichain {antichain}")
        if len(candidates) == 0:
            print("  Append first")
            candidates.append(antichain)
        else:
            new = True
            for i in range(len(candidates)):
                candidate = candidates[i]
                if antichain > candidate:
                    print(f"  superset of candidate {candidate}")
                    # antichain is a superset of an existing candidate, we replace it
                    candidates[i] = antichain
                    new = False
                    break
                elif antichain < antichain:
                    print(f"  subset of candidate {candidate}")
                    # antichain is a subset of an existing candidate, we can ignore it
                    new = False
                    break
            if new:
                print(f"  new candidate")
                candidates.append(antichain)

    return candidates


# %% Index sets

LVL1 = "Level 1"
LVL2 = "Level 2"
LVL3 = "Level 3"
PO = "Part-of"

tops = (80, 256)  # entity  # thing
food = (
    5,  # apple
    18,  # avocado
    21,  # banana
    22,  # bean
    29,  # blackberry
    33,  # blush_wine
    43,  # cabbage
    51,  # citron
    52,  # coconut1
    53,  # coconut2
    55,  # coffee
    57,  # coffee_bean
    60,  # corn
    62,  # corn_whiskey
    75,  # eggplant
    85,  # fig
    101,  # gelatin
    102,  # grape
    # 118,  # hay
    140,  # lemon
    151,  # melon
    159,  # nectar
    162,  # orange
    174,  # pea
    177,  # pear
    181,  # pepper3
    182,  # pepper4
    185,  # pieplant
    212,  # radish
    225,  # sage
    247,  # strawberry
    249,  # sugar
    269,  # tomato
    # MEDS
    27,  # berry
    71,  # dessert
    127,  # jam
    129,  # jelly
    227,  # salad
    230,  # seed
    251,  # sweet
    # PARTS OF
    243,  # spice
    # TOPS
    2,  # ambrosia
    112,  # greens
    95,  # fruit
    74,  # eatage
    282,  # vegetable
    121,  # herb
) + tops

food_sections = {5: LVL1, 27: LVL2, 243: PO, 2: LVL3}
granimal = (
    1,
    6,
    15,
    16,
    19,
    20,
    23,
    24,
    25,
    28,
    30,
    36,
    39,
    40,
    44,
    45,
    49,
    50,
    54,
    56,
    58,
    59,
    66,
    67,
    72,
    73,
    76,
    77,
    78,
    84,
    88,
    89,
    95,
    103,
    105,
    120,
    123,
    125,
    135,
    137,
    141,
    144,
    148,
    149,
    152,
    154,
    155,
    156,
    160,
    164,
    171,
    175,
    176,
    178,
    179,
    180,
    184,
    186,
    187,
    205,
    206,
    213,
    216,
    218,
    222,
    226,
    230,
    231,
    234,
    268,
    270,
    273,
    276,
    278,
    283,
    284,
    285,
    288,
    290,
    292,
) + tops
plant = (
    30,  # blackberry
    45,  # capsicum
    # 50, # chrysantemum2
    49,  # chrysantemum1
    56,  # coffee
    58,  # corn
    66,  # daffodil
    67,  # daisy
    76,  # eggplant
    123,  # honeysuckle
    125,  # hyacinth
    135,  # larkspur
    144,  # lilac
    152,  # melon
    155,  # myrtle
    # 156, # myrtle2
    160,  # oleander
    176,  # pea
    179,  # peony
    180,  # pepper
    184,  # petal
    205,  # pod
    206,  # poppy
    213,  # radish_plant
    216,  # rocket
    222,  # rose
    226,  # sage
    278,  # tulip
    268,  # tobacco
    270,  # tomato
    285,  # violet
    284,  # verbena
    288,  # wallflower
    # MEDS
    24,  # bean
    44,  # cabbage
    154,  # moss
    103,  # grape
    # PARTS OF
    36,  # branch
    40,  # bud
    230,  # seed
    137,  # leaf
    218,  # root
    28,  # berry
    # TOPS
    283,  # vegetable
    95,  # fruit
    120,  # herb
    105,  # grass
    234,  # shrub
    88,  # flower1
    89,  # florew2
    166,  # organism
    197,  # plant
) + tops

plant_sections = {30: LVL1, 24: LVL2, 36: PO, 283: LVL3}

tree = (
    6,  # apple
    15,  # ash
    19,  # avocado
    20,  # banana #
    25,  # beech
    54,  # coconut
    72,  # dogwood #
    77,  # elm
    84,  # fig
    141,  # lemon
    149,  # maple
    164,  # orange
    178,  # pear
    292,  # willow
    186,  # pine
    # MED
    171,  # palm
    # PARTS
    218,  # root
    276,  # trunk
    # TOP
    273,  # tree
    166,  # organism
    197,  # plant
) + tops

tree_sections = {6: LVL1, 171: LVL2, 218: PO, 273: LVL3}
actual_tree = (
    6,
    15,
    19,
    20,
    25,
    54,
    72,
    66,
    84,
    141,
    149,
    164,
    171,
    178,
    186,
    197,
    256,
    273,
    292,
    80,
    166,
)

sel = (
    77, # elm
    98, # garden
    151, # melon
    95, # fruit
    197, # plant
    43, # cabbage
    21, # banana
    # 80, # entity
    256
)


# %%
plt.rcParams["font.size"] = 13  # 17


def trunc(s, length):
    return s[: length - 3] + "~" + s[-2:] if len(s) > length else s


index_sets = [food, plant]
section_sets = [food_sections, plant_sections]

index_sets = [tree]
section_sets = [tree_sections]

assert len(index_sets) == len(section_sets)

num_synsets = list(map(len, index_sets))
mat_sizes = [num // 3.8 for num in num_synsets]

COUNT_BARH_WIDTH = 4.5
CBAR_HEIGHT = 0.1
CMAP = "BrBG_r"
TRUNC_L = 9

total_height = sum(mat_sizes) + CBAR_HEIGHT
total_width = max(mat_sizes) + COUNT_BARH_WIDTH

mat_height_ratios = [size / total_height for size in mat_sizes]
cbar_height_ratio = CBAR_HEIGHT / total_height
mats_width_ratio = max(mat_sizes) / total_width
barh_width_ratio = COUNT_BARH_WIDTH / total_width

gs = GridSpec(
    nrows=len(index_sets) + 1,
    ncols=2,
    width_ratios=[mats_width_ratio, barh_width_ratio],
    height_ratios=[*mat_height_ratios, cbar_height_ratio],
)

f = plt.figure(figsize=(total_width, total_height))

hbar = None
mat_axes, barh_axes = zip(
    *[
        (
            mat := f.add_subplot(gs[i, 0]),
            hbar := f.add_subplot(gs[i, 1], sharey=mat, sharex=hbar),
        )
        for i in range(len(index_sets))
    ]
)
cbar_axis = f.add_subplot(gs[len(index_sets), 0])

gs.tight_layout(f, h_pad=5, w_pad=0)

im = None
label_sets = [label_subset(labels, indices) for indices in index_sets]


def mklab(indices, sections):
    sublabels = label_subset(labels, indices)
    for i, idx in enumerate(indices):
        if idx not in sections:
            continue
        sublabels[i] = f"$\\bf{{{sections[idx]}}} $ - {sublabels[i]}"

    return sublabels


for sublabels, sections, indices, ax in zip(
    label_sets, section_sets, index_sets, mat_axes
):
    subssm = ssm_subset(ssm, indices)
    amount = len(indices)

    sectioned_sublabels = mklab(indices, sections)

    im = ax.matshow(subssm, cmap=CMAP)
    ax.set_yticks(range(amount), sectioned_sublabels)
    ax.set_xticks(
        range(amount), [trunc(lab, TRUNC_L) for lab in sublabels], rotation=-90
    )

for sublabels, indices, ax in zip(label_sets, index_sets, barh_axes):
    counts = count_subset(count_dict, sublabels)

    ypos = range(len(indices))
    ax.barh(ypos, counts, align="center", edgecolor="black", linewidth=1, color="none")
    ax.set_title("№ occurrences (log)")
    ax.set_xscale("log")
    plt.setp(ax.get_yticklabels(), visible=False)

cbar = f.colorbar(
    im,
    cax=cbar_axis,
    orientation="horizontal",
)

cbar.ax.set_xticks(
    [-1, 0, 1],
    [
        "-1 \n(→ is less abstract than ↓)",
        "0\n(no abstraction)",
        "1\n(→ is more abstract than ↓)",
    ],
)

f.savefig("ssms_tree.pdf", bbox_inches="tight")

plt.show()

# %%

def plot_graph(G):
    pos = nx.spring_layout(G)
    nx.draw_networkx(G, pos, with_labels=True)
    # labels = nx.get_edge_attributes(G, 'weight')
    # nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)

# %%
import networkx as nx

tree_subset = (54, 171, 273, 186, 77)
plant_subset = (197, 256, 66, 285, 88)

flowers = (278, 197, 88, 166, 80, 66)

planttreeflower = (256, 80, 273, 197, 88, 66)

fruitberry = (256, 80, 247, 27, 95, 162, 102)

idcs = sel
# idcs = tree_subset
threshold = 0.0  # planttreeflowe 0.05

tree_l = label_subset(labels, idcs)
ssm_l = ssm_subset(ssm, idcs)

for thresh in [0.3]:#[0.02, 0.08, 0.1, 0.3]:

    adjacency = ssm_l.copy()
    # adjacency[adjacency < 0.7] = 0

    g = nx.from_numpy_array(adjacency, create_using=nx.DiGraph)
    g_named = nx.relabel_nodes(g, {i: label for i, label in enumerate(tree_l)})
    g_named.remove_edges_from(
        [(n1, n2) for n1, n2, w in g_named.edges(data="weight") if w < thresh]
    )
    g_trans = nx.transitive_reduction(g_named)
    # plot_graph(g_named)
    # plt.figure()
    plt.figure(figsize=(20, 20))
    plot_graph(g_trans)
    print("\nt=%s" % thresh)
    for (fst, snd) in g_trans.edges():
        print(f"{fst}-->{snd}: {ssmv(fst,snd):.2f}")

#%%
def sumstuff(fr, to, edges, current):
    val = ssmv(fr, to)
    current += val
    print(f"{to},{val:.3E},{current:.2f},{count_dict[to]}")
    next_edges = [(nfr, nto) for (nfr, nto) in edges if nfr == to]
    if len(next_edges) == 0:
        return
    nfr, nto = next_edges[0]
    sumstuff(nfr, nto, edges, current)

print("topographic_point.1,0,%s" % count_dict['topographic_point.1'])
sumstuff('topographic_point.1', 'thing.3', g_trans.edges(), 0)
# %%
import itertools as it

argwhere_bound = 0.5

t = nx.DiGraph()
t.add_nodes_from(g)
path = nx.dag_longest_path(g)
for node in it.islice(reversed(path), 1, None):
    row = ssm_l[node]
    for i in np.argwhere(row > argwhere_bound).flatten():
        t.add_edge(node, i)

nx.draw(
    nx.relabel_nodes(
        nx.transitive_reduction(t), {i: label for i, label in enumerate(tree_l)}
    ),
    with_labels=True,
)
# %%
# t-test

mean_abstraction = ssm.mean(axis=1)
the_counts = [count_dict[lab] for lab in labels]

import scipy.stats

print(scipy.stats.pearsonr(mean_abstraction, the_counts))

# %% Transitivity check I


for thresh in [0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]:
    fig, (ax1, ax2) = plt.subplots(1, 2)
    A = ssm.copy()
    A[A <= thresh] = 0
    A[A > thresh] = 1
    ax1.matshow(A, cmap="binary")
    trans = A @ A
    trans[A > 0] = 0
    print(np.any(trans > 0))
    ax2.matshow(trans, cmap="binary")
    fig.show()

# %% Transitivity check II
import itertools as it


def transitive(X):
    for i, j in it.product(range(302), range(302)):
        if X[i, j]:
            for k in np.argwhere(X[j]).flatten():
                # we know X[j, k] == 1, so we need X[i, k] == 1 as well
                if not X[i, k]:
                    return False

    return True


for thresh in [0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]:
    A = ssm.copy()
    A[A <= thresh] = 0
    A[A > thresh] = 1
    print(thresh, transitive(A))

# %%

all_counts = [count_dict[lab] for lab in labels]
all_means = [means(lab) for lab in labels]

plt.scatter(all_means, all_counts, c="black")
plt.hlines(768, -1, 1, ls=":")
plt.yscale("log")
# %%
fig, ax = plt.subplots(1, 1, figsize=(6 * 0.9, 4 * 0.9))
fig.tight_layout()
ax.axvline(768, ls=":", c="gray")
ax.axhline(0, ls=":", c="gray")
ax.scatter(all_counts, all_means, c="black", s=5)
ax.set_ylim([-1, 1])
ax.set_xscale("log")
ax.set_yticks([-1, -0.5, 0, 0.5, 1])
ax.text(800, -0.95, "$d_{BERT}$", size="small", c="gray")
ax.set_xlabel("Synset occurrence count (log)")
ax.set_ylabel("Average synset abstraction")
fig.savefig("../data/plots/counts.pdf", bbox_inches="tight", pad_inches=0)


#%%
fig, ax = plt.subplots(1, 1, figsize=(6 * 0.9, 4 * 0.9))
fig.tight_layout()
ax.axvline(768, ls=":", c="gray")
ax.axhline(0, ls=":", c="gray")
ax.scatter(all_counts, all_means, c="black", s=5)
ax.set_ylim([-1, 1])
# a1.set_xscale("log")
ax.set_yticks([-1, -0.5, 0, 0.5, 1])
ax.text(800, -.95, "$d_{BERT}$", size='small', c='gray')
ax.set_xlabel("Synset occurrence count")
ax.set_ylabel("Average synset abstraction")

fig.savefig("../data/plots/counts1.pdf", bbox_inches="tight", pad_inches=0)

# %%

# buff = ["x;y;z;xy;yz;xz;sum;diff"]
import itertools as it
from math import factorial

from tqdm import tqdm

diffs = []

failures = []

minnorm = lambda x,y: min(x,y)
lukasiewicz = lambda x,y: max(x+y-1, 0)
prod = lambda x,y: x*y
drastic = lambda x,y: min(x,y) if max(x,y) = 1

ssmt = ssm.copy()
ssmt[ssmt<0] = 0

t = prod

for x, y, z in tqdm(
    it.combinations(range(302), 3),
):
    xy = ssmt[x, y]
    yz = ssmt[y, z]
    xz = ssmt[x, z]

    if xz < t(xy, yz):
        print("fail!", xy, yz, xz)
        break
    

# with open("test.csv", "w") as file:
#     file.write("\n".join(buff))

# %%
fig, ax = plt.subplots(1, 1, figsize=(6, 4))
fig.tight_layout()

ax.hist(diffs, bins=30, color="black", rwidth=0.90)
ax.set_xlabel("Value for $\succ(x,y)\ +\ \succ(y,z)\ -\ \succ(x,z)$")
ax.set_ylabel("Count")

# %%
